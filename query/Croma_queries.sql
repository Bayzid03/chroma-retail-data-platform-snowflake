/**Chroma Retail Chain Data Engineering Project**/
Objective: Chroma, a retail brand with diverse product lines (electronics,home goods, etc.), generates large volumes of data every day.
Transform Chroma’s scattered operational data into a central, trusted, and automated analytics hub using Snowflake + Azure.

Source: Azure Blob Storage container
Ingestion: Snowpipe
Database/Schemas: CHROMA
1) STG (raw landing; loaded by Snowpipe)
2) INT (conformed dimensions & facts)
3) PRS (presentation views for BI)

-- Warehouses
CREATE WAREHOUSE IF NOT EXISTS WH_INGEST
  WAREHOUSE_SIZE = XSMALL AUTO_SUSPEND = 60 AUTO_RESUME = TRUE; -- Define warehouse size and auto suspend/resume
CREATE WAREHOUSE IF NOT EXISTS WH_TRANSFORM
  WAREHOUSE_SIZE = SMALL AUTO_SUSPEND = 60 AUTO_RESUME = TRUE;
 
-- Database & Schemas
CREATE DATABASE IF NOT EXISTS CHROMA;
CREATE SCHEMA IF NOT EXISTS CHROMA.STG;
CREATE SCHEMA IF NOT EXISTS CHROMA.INT;
CREATE SCHEMA IF NOT EXISTS CHROMA.PRS;

-- Standard CSV file format (matches the generated files)
CREATE OR REPLACE FILE FORMAT CHROMA.PUBLIC.FF_CSV_STD
  TYPE = CSV
  FIELD_DELIMITER = ','
  SKIP_HEADER = 1
  FIELD_OPTIONALLY_ENCLOSED_BY = '"'
  NULL_IF = ('', 'NULL', 'null');
  
-- Storage integration (Azure AD consent required)
CREATE OR REPLACE STORAGE INTEGRATION AZURE_BLOB_INT;
  TYPE = EXTERNAL_STAGE
  STORAGE_PROVIDER = AZURE
  ENABLED = TRUE
  AZURE_TENANT_ID = 'f4722d32-822b-43d8-9f2c-55cf3e3978db'
  STORAGE_ALLOWED_LOCATIONS = ('azure://azure2snowflakedemo.blob.core.windows.net/croma/');

DESC INTEGRATION AZURE_BLOB_INT; -- Describe the storage integration
  
CREATE OR REPLACE NOTIFICATION INTEGRATION MY_NOTIFICATION_INT
	  ENABLED = TRUE
	  TYPE = QUEUE
	  NOTIFICATION_PROVIDER = AZURE_STORAGE_QUEUE
	  AZURE_STORAGE_QUEUE_PRIMARY_URI = 'https://azure2snowflakedemo.queue.core.windows.net/snowpipequeue'
	  AZURE_TENANT_ID = 'f4722d32-822b-43d8-9f2c-55cf3e3978db';

desc NOTIFICATION INTEGRATION MY_NOTIFICATION_INT; -- Describe the notification integration

-- External stage 
CREATE OR REPLACE STAGE CHROMA.STG.AZ_STAGE
  URL = 'azure://azure2snowflakedemo.blob.core.windows.net/croma/'
  STORAGE_INTEGRATION = AZURE_BLOB_INT
  FILE_FORMAT = CHROMA.PUBLIC.FF_CSV_STD;

LIST @CHROMA.STG.AZ_STAGE/product; -- List files in the stage
desc stage CHROMA.STG.AZ_STAGE; -- Describe the stage
list @CHROMA.STG.AZ_STAGE; -- List files in the stage

USE SCHEMA CHROMA.STG;

CREATE OR REPLACE TABLE STG_PRODUCT ( 
  PRODUCT_ID   NUMBER,
  PRODUCT_SKU  STRING,
  PRODUCT_NAME STRING,
  BRAND        STRING,
  CATEGORY     STRING,
  SUBCATEGORY  STRING,
  COLOR        STRING,
  SIZE         STRING,
  UNIT_PRICE   NUMBER(10,2),
  START_DATE   DATE,
  END_DATE     DATE,
  IS_ACTIVE    NUMBER(1)
);

CREATE OR REPLACE TABLE STG_EMPLOYEE (
  EMPLOYEE_ID       NUMBER,
  FIRST_NAME        STRING,
  LAST_NAME         STRING,
  EMAIL             STRING,
  PHONE             STRING,
  HIRE_DATE         DATE,
  TERMINATION_DATE  DATE,
  STORE_ID          NUMBER,
  JOB_TITLE         STRING
);

CREATE OR REPLACE TABLE STG_CUSTOMER (
  CUSTOMER_ID   NUMBER,
  FIRST_NAME    STRING,
  LAST_NAME     STRING,
  EMAIL         STRING,
  PHONE         STRING,
  BIRTH_DATE    DATE,
  GENDER        STRING,
  ADDRESS       STRING,
  CITY          STRING,
  STATE         STRING,
  POSTAL_CODE   STRING,
  COUNTRY       STRING,
  SIGNUP_DATE   DATE,
  LOYALTY_TIER  STRING
);

CREATE OR REPLACE TABLE STG_STORE (
  STORE_ID      NUMBER,
  STORE_NAME    STRING,
  STORE_NUMBER  NUMBER,
  FORMAT        STRING,
  ADDRESS       STRING,
  CITY          STRING,
  STATE         STRING,
  POSTAL_CODE   STRING,
  COUNTRY       STRING,
  REGION        STRING,
  OPEN_DATE     DATE,
  CLOSE_DATE    DATE,
  SQ_FT         NUMBER
);

CREATE OR REPLACE TABLE STG_SALES (
  SALES_ID         NUMBER,
  SALES_DATE       DATE,
  SALES_TIME       TIME,
  STORE_ID         NUMBER,
  PRODUCT_ID       NUMBER,
  CUSTOMER_ID      NUMBER,
  EMPLOYEE_ID      NUMBER,
  QUANTITY         NUMBER,
  UNIT_PRICE       NUMBER(10,2),
  GROSS_AMOUNT     NUMBER(12,2),
  DISCOUNT_AMOUNT  NUMBER(12,2),
  NET_AMOUNT       NUMBER(12,2),
  PAYMENT_TYPE     STRING,
  TRANSACTION_ID   STRING
);

CREATE OR REPLACE TABLE STG_INVENTORY (
  INVENTORY_ID   NUMBER,
  SNAPSHOT_DATE  DATE,
  STORE_ID       NUMBER,
  PRODUCT_ID     NUMBER,
  ON_HAND_QTY    NUMBER,
  ON_ORDER_QTY   NUMBER,
  REORDER_POINT  NUMBER,
  UNIT_COST      NUMBER(10,2)
);

================================================================================
-- PRODUCT
-- Create a pipe to automatically ingest data from Azure Blob Storage
CREATE OR REPLACE PIPE CHROMA.STG.P_PRODUCT 
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_PRODUCT
FROM @CHROMA.STG.AZ_STAGE/product
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD);

select SYSTEM$PIPE_STATUS('P_PRODUCT') -- Check the status of the pipe

-- EMPLOYEE
CREATE OR REPLACE PIPE CHROMA.STG.P_EMPLOYEE
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_EMPLOYEE
FROM @CHROMA.STG.AZ_STAGE/employee
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD)

-- CUSTOMER
CREATE OR REPLACE PIPE CHROMA.STG.P_CUSTOMER
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_CUSTOMER
FROM @CHROMA.STG.AZ_STAGE/customer
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD)

-- STORE
CREATE OR REPLACE PIPE CHROMA.STG.P_STORE
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_STORE
FROM @CHROMA.STG.AZ_STAGE/store
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD)

-- SALES
CREATE OR REPLACE PIPE CHROMA.STG.P_SALES
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_SALES
FROM @CHROMA.STG.AZ_STAGE/sales
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD)

-- EMPLOYEE
CREATE OR REPLACE PIPE CHROMA.STG.P_EMPLOYEE
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_EMPLOYEE
FROM @CHROMA.STG.AZ_STAGE/employee
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD)

-- INVENTORY
CREATE OR REPLACE PIPE CHROMA.STG.P_INVENTORY
  AUTO_INGEST = TRUE
  INTEGRATION = 'MY_NOTIFICATION_INT'
AS
COPY INTO CHROMA.STG.STG_INVENTORY
FROM @CHROMA.STG.AZ_STAGE/inventory
FILE_FORMAT = (FORMAT_NAME = CHROMA.PUBLIC.FF_CSV_STD)

	USE DATABASE CHROMA;
	USE SCHEMA CHROMA.INT;

-- This is part of my 'INT' schema, where data is cleaned, conformed, and modeled for analytics.

-- ============= DIMENSIONS =============

CREATE OR REPLACE TABLE DIM_PRODUCT (
  PRODUCT_KEY   NUMBER IDENTITY START 1,
  PRODUCT_ID    NUMBER,         -- natural key from STG
  PRODUCT_SKU   STRING,
  PRODUCT_NAME  STRING,
  BRAND         STRING,
  CATEGORY      STRING,
  SUBCATEGORY   STRING,
  COLOR         STRING,
  SIZE          STRING,
  UNIT_PRICE    NUMBER(10,2),
  START_DATE    DATE,
  END_DATE      DATE,
  IS_ACTIVE     NUMBER(1),
  CONSTRAINT PK_DIM_PRODUCT PRIMARY KEY (PRODUCT_KEY) NOT ENFORCED
);

CREATE OR REPLACE TABLE DIM_EMPLOYEE (
  EMPLOYEE_KEY     NUMBER IDENTITY START 1,
  EMPLOYEE_ID      NUMBER,
  FIRST_NAME       STRING,
  LAST_NAME        STRING,
  EMAIL            STRING,
  PHONE            STRING,
  HIRE_DATE        DATE,
  TERMINATION_DATE DATE,
  STORE_ID         NUMBER,
  JOB_TITLE        STRING,
  CONSTRAINT PK_DIM_EMPLOYEE PRIMARY KEY (EMPLOYEE_KEY) NOT ENFORCED
);

CREATE OR REPLACE TABLE DIM_CUSTOMER (
  CUSTOMER_KEY   NUMBER IDENTITY START 1,
  CUSTOMER_ID    NUMBER,
  FIRST_NAME     STRING,
  LAST_NAME      STRING,
  EMAIL          STRING,
  PHONE          STRING,
  BIRTH_DATE     DATE,
  GENDER         STRING,
  CITY           STRING,
  STATE          STRING,
  POSTAL_CODE    STRING,
  COUNTRY        STRING,
  SIGNUP_DATE    DATE,
  LOYALTY_TIER   STRING,
  CONSTRAINT PK_DIM_CUSTOMER PRIMARY KEY (CUSTOMER_KEY) NOT ENFORCED
);

CREATE OR REPLACE TABLE DIM_STORE (
  STORE_KEY     NUMBER IDENTITY START 1,
  STORE_ID      NUMBER,
  STORE_NAME    STRING,
  STORE_NUMBER  NUMBER,
  FORMAT        STRING,
  CITY          STRING,
  STATE         STRING,
  POSTAL_CODE   STRING,
  COUNTRY       STRING,
  REGION        STRING,
  OPEN_DATE     DATE,
  CLOSE_DATE    DATE,
  SQ_FT         NUMBER,
  CONSTRAINT PK_DIM_STORE PRIMARY KEY (STORE_KEY) NOT ENFORCED
);

-- ============= FACTS =============

CREATE OR REPLACE TABLE FACT_SALES (
  SALES_KEY        NUMBER IDENTITY START 1,
  SALES_ID         NUMBER,   -- natural key from STG
  SALES_DATE       DATE,
  SALES_TIME       TIME,
  STORE_KEY        NUMBER,
  PRODUCT_KEY      NUMBER,
  CUSTOMER_KEY     NUMBER,
  EMPLOYEE_KEY     NUMBER,
  QUANTITY         NUMBER,
  UNIT_PRICE       NUMBER(10,2),
  GROSS_AMOUNT     NUMBER(12,2),
  DISCOUNT_AMOUNT  NUMBER(12,2),
  NET_AMOUNT       NUMBER(12,2),
  PAYMENT_TYPE     STRING,
  TRANSACTION_ID   STRING,
  CONSTRAINT FK_FS_STORE    FOREIGN KEY (STORE_KEY)    REFERENCES DIM_STORE(STORE_KEY) NOT ENFORCED,
  CONSTRAINT FK_FS_PRODUCT  FOREIGN KEY (PRODUCT_KEY)  REFERENCES DIM_PRODUCT(PRODUCT_KEY) NOT ENFORCED,
  CONSTRAINT FK_FS_CUSTOMER FOREIGN KEY (CUSTOMER_KEY) REFERENCES DIM_CUSTOMER(CUSTOMER_KEY) NOT ENFORCED,
  CONSTRAINT FK_FS_EMPLOYEE FOREIGN KEY (EMPLOYEE_KEY) REFERENCES DIM_EMPLOYEE(EMPLOYEE_KEY) NOT ENFORCED
);

CREATE OR REPLACE TABLE FACT_INVENTORY (
  INVENTORY_KEY    NUMBER IDENTITY START 1,
  INVENTORY_ID     NUMBER,  -- natural key from STG
  SNAPSHOT_DATE    DATE,
  STORE_KEY        NUMBER,
  PRODUCT_KEY      NUMBER,
  ON_HAND_QTY      NUMBER,
  ON_ORDER_QTY     NUMBER,
  REORDER_POINT    NUMBER,
  UNIT_COST        NUMBER(10,2),
  CONSTRAINT FK_FI_STORE   FOREIGN KEY (STORE_KEY)   REFERENCES DIM_STORE(STORE_KEY) NOT ENFORCED,
  CONSTRAINT FK_FI_PRODUCT FOREIGN KEY (PRODUCT_KEY) REFERENCES DIM_PRODUCT(PRODUCT_KEY) NOT ENFORCED
);

==================================
-- PRODUCT
-- Upserts product records from staging to dimension table using Type 1 SCD logic (overwrite on match).
-- Ensures DIM_PRODUCT stays current with latest product attributes from STG_PRODUCT.

MERGE INTO CHROMA.INT.DIM_PRODUCT d
USING (
  SELECT DISTINCT
    PRODUCT_ID, PRODUCT_SKU, PRODUCT_NAME, BRAND, CATEGORY, SUBCATEGORY,
    COLOR, SIZE, UNIT_PRICE, START_DATE, END_DATE, IS_ACTIVE
  FROM CHROMA.STG.STG_PRODUCT
) s
ON d.PRODUCT_ID = s.PRODUCT_ID
WHEN MATCHED THEN UPDATE SET
  PRODUCT_SKU=s.PRODUCT_SKU, PRODUCT_NAME=s.PRODUCT_NAME, BRAND=s.BRAND,
  CATEGORY=s.CATEGORY, SUBCATEGORY=s.SUBCATEGORY, COLOR=s.COLOR, SIZE=s.SIZE,
  UNIT_PRICE=s.UNIT_PRICE, START_DATE=s.START_DATE, END_DATE=s.END_DATE, IS_ACTIVE=s.IS_ACTIVE
WHEN NOT MATCHED THEN INSERT (
  PRODUCT_ID, PRODUCT_SKU, PRODUCT_NAME, BRAND, CATEGORY, SUBCATEGORY,
  COLOR, SIZE, UNIT_PRICE, START_DATE, END_DATE, IS_ACTIVE
) VALUES (
  s.PRODUCT_ID, s.PRODUCT_SKU, s.PRODUCT_NAME, s.BRAND, s.CATEGORY, s.SUBCATEGORY,
  s.COLOR, s.SIZE, s.UNIT_PRICE, s.START_DATE, s.END_DATE, s.IS_ACTIVE
);

-- EMPLOYEE
-- Upserts employee records from staging to dimension table using Type 1 SCD logic (overwrite on match).
-- Ensures DIM_EMPLOYEE stays current with latest employee attributes from STG_EMPLOYEE.

MERGE INTO CHROMA.INT.DIM_EMPLOYEE d
USING (
  SELECT DISTINCT
    EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE,
    HIRE_DATE, TERMINATION_DATE, STORE_ID, JOB_TITLE
  FROM CHROMA.STG.STG_EMPLOYEE
) s
ON d.EMPLOYEE_ID = s.EMPLOYEE_ID
WHEN MATCHED THEN UPDATE SET
  FIRST_NAME=s.FIRST_NAME, LAST_NAME=s.LAST_NAME, EMAIL=s.EMAIL, PHONE=s.PHONE,
  HIRE_DATE=s.HIRE_DATE, TERMINATION_DATE=s.TERMINATION_DATE, STORE_ID=s.STORE_ID, JOB_TITLE=s.JOB_TITLE
WHEN NOT MATCHED THEN INSERT (
  EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE,
  HIRE_DATE, TERMINATION_DATE, STORE_ID, JOB_TITLE
) VALUES (
  s.EMPLOYEE_ID, s.FIRST_NAME, s.LAST_NAME, s.EMAIL, s.PHONE,
  s.HIRE_DATE, s.TERMINATION_DATE, s.STORE_ID, s.JOB_TITLE
);

-- CUSTOMER
-- Upserts customer records from staging to dimension table using Type 1 SCD logic (overwrite on match).
-- Ensures DIM_CUSTOMER stays current with latest customer attributes from STG_CUSTOMER.

MERGE INTO CHROMA.INT.DIM_CUSTOMER d
USING (
  SELECT DISTINCT
    CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, BIRTH_DATE, GENDER,
    CITY, STATE, POSTAL_CODE, COUNTRY, SIGNUP_DATE, LOYALTY_TIER
  FROM CHROMA.STG.STG_CUSTOMER
) s
ON d.CUSTOMER_ID = s.CUSTOMER_ID
WHEN MATCHED THEN UPDATE SET
  FIRST_NAME=s.FIRST_NAME, LAST_NAME=s.LAST_NAME, EMAIL=s.EMAIL, PHONE=s.PHONE,
  BIRTH_DATE=s.BIRTH_DATE, GENDER=s.GENDER, CITY=s.CITY, STATE=s.STATE, POSTAL_CODE=s.POSTAL_CODE,
  COUNTRY=s.COUNTRY, SIGNUP_DATE=s.SIGNUP_DATE, LOYALTY_TIER=s.LOYALTY_TIER
WHEN NOT MATCHED THEN INSERT (
  CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, BIRTH_DATE, GENDER,
  CITY, STATE, POSTAL_CODE, COUNTRY, SIGNUP_DATE, LOYALTY_TIER
) VALUES (
  s.CUSTOMER_ID, s.FIRST_NAME, s.LAST_NAME, s.EMAIL, s.PHONE, s.BIRTH_DATE, s.GENDER,
  s.CITY, s.STATE, s.POSTAL_CODE, s.COUNTRY, s.SIGNUP_DATE, s.LOYALTY_TIER
);

-- STORE
-- Upserts store records from staging to dimension table using Type 1 SCD logic (overwrite on match).
-- Ensures DIM_STORE stays current with latest store attributes from STG_STORE.

MERGE INTO CHROMA.INT.DIM_STORE d
USING (
  SELECT DISTINCT
    STORE_ID, STORE_NAME, STORE_NUMBER, FORMAT, CITY, STATE, POSTAL_CODE, COUNTRY,
    REGION, OPEN_DATE, CLOSE_DATE, SQ_FT
  FROM CHROMA.STG.STG_STORE
) s
ON d.STORE_ID = s.STORE_ID
WHEN MATCHED THEN UPDATE SET
  STORE_NAME=s.STORE_NAME, STORE_NUMBER=s.STORE_NUMBER, FORMAT=s.FORMAT, CITY=s.CITY, STATE=s.STATE,
  POSTAL_CODE=s.POSTAL_CODE, COUNTRY=s.COUNTRY, REGION=s.REGION, OPEN_DATE=s.OPEN_DATE,
  CLOSE_DATE=s.CLOSE_DATE, SQ_FT=s.SQ_FT
WHEN NOT MATCHED THEN INSERT (
  STORE_ID, STORE_NAME, STORE_NUMBER, FORMAT, CITY, STATE, POSTAL_CODE, COUNTRY, REGION, OPEN_DATE, CLOSE_DATE, SQ_FT
) VALUES (
  s.STORE_ID, s.STORE_NAME, s.STORE_NUMBER, s.FORMAT, s.CITY, s.STATE, s.POSTAL_CODE, s.COUNTRY, s.REGION, s.OPEN_DATE, s.CLOSE_DATE, s.SQ_FT
);

===================================================
-- FACT_SALES
-- Upserts sales records from staging to fact table using Type 1 SCD logic (overwrite on match).
-- Ensures FACT_SALES stays current with latest sales attributes from STG_SALES.

MERGE INTO CHROMA.INT.FACT_SALES t
USING (
  SELECT
    s.SALES_ID, s.SALES_DATE, s.SALES_TIME,
    ds.STORE_KEY, dp.PRODUCT_KEY, dc.CUSTOMER_KEY, de.EMPLOYEE_KEY,
    s.QUANTITY, s.UNIT_PRICE, s.GROSS_AMOUNT, s.DISCOUNT_AMOUNT, s.NET_AMOUNT,
    s.PAYMENT_TYPE, s.TRANSACTION_ID
  FROM CHROMA.STG.STG_SALES s
  LEFT JOIN CHROMA.INT.DIM_STORE    ds ON ds.STORE_ID    = s.STORE_ID
  LEFT JOIN CHROMA.INT.DIM_PRODUCT  dp ON dp.PRODUCT_ID  = s.PRODUCT_ID
  LEFT JOIN CHROMA.INT.DIM_CUSTOMER dc ON dc.CUSTOMER_ID = s.CUSTOMER_ID
  LEFT JOIN CHROMA.INT.DIM_EMPLOYEE de ON de.EMPLOYEE_ID = s.EMPLOYEE_ID
) s
ON t.SALES_ID = s.SALES_ID
WHEN MATCHED THEN UPDATE SET
  SALES_DATE = s.SALES_DATE, SALES_TIME = s.SALES_TIME,
  STORE_KEY = s.STORE_KEY, PRODUCT_KEY = s.PRODUCT_KEY,
  CUSTOMER_KEY = s.CUSTOMER_KEY, EMPLOYEE_KEY = s.EMPLOYEE_KEY,
  QUANTITY = s.QUANTITY, UNIT_PRICE = s.UNIT_PRICE,
  GROSS_AMOUNT = s.GROSS_AMOUNT, DISCOUNT_AMOUNT = s.DISCOUNT_AMOUNT,
  NET_AMOUNT = s.NET_AMOUNT, PAYMENT_TYPE = s.PAYMENT_TYPE, TRANSACTION_ID = s.TRANSACTION_ID
WHEN NOT MATCHED THEN INSERT (
  SALES_ID, SALES_DATE, SALES_TIME, STORE_KEY, PRODUCT_KEY, CUSTOMER_KEY, EMPLOYEE_KEY,
  QUANTITY, UNIT_PRICE, GROSS_AMOUNT, DISCOUNT_AMOUNT, NET_AMOUNT, PAYMENT_TYPE, TRANSACTION_ID
) VALUES (
  s.SALES_ID, s.SALES_DATE, s.SALES_TIME, s.STORE_KEY, s.PRODUCT_KEY, s.CUSTOMER_KEY, s.EMPLOYEE_KEY,
  s.QUANTITY, s.UNIT_PRICE, s.GROSS_AMOUNT, s.DISCOUNT_AMOUNT, s.NET_AMOUNT, s.PAYMENT_TYPE, s.TRANSACTION_ID
);

-- FACT_INVENTORY
-- Upserts inventory records from staging to fact table using Type 1 SCD logic (overwrite on match).
-- Ensures FACT_INVENTORY stays current with latest inventory attributes from STG_INVENTORY.

MERGE INTO CHROMA.INT.FACT_INVENTORY t
USING (
  SELECT
    i.INVENTORY_ID, i.SNAPSHOT_DATE,
    ds.STORE_KEY, dp.PRODUCT_KEY,
    i.ON_HAND_QTY, i.ON_ORDER_QTY, i.REORDER_POINT, i.UNIT_COST
  FROM CHROMA.STG.STG_INVENTORY i
  LEFT JOIN CHROMA.INT.DIM_STORE   ds ON ds.STORE_ID   = i.STORE_ID
  LEFT JOIN CHROMA.INT.DIM_PRODUCT dp ON dp.PRODUCT_ID = i.PRODUCT_ID
) s
ON t.INVENTORY_ID = s.INVENTORY_ID
WHEN MATCHED THEN UPDATE SET
  SNAPSHOT_DATE = s.SNAPSHOT_DATE,
  STORE_KEY     = s.STORE_KEY,
  PRODUCT_KEY   = s.PRODUCT_KEY,
  ON_HAND_QTY   = s.ON_HAND_QTY,
  ON_ORDER_QTY  = s.ON_ORDER_QTY,
  REORDER_POINT = s.REORDER_POINT,
  UNIT_COST     = s.UNIT_COST
WHEN NOT MATCHED THEN INSERT (
  INVENTORY_ID, SNAPSHOT_DATE, STORE_KEY, PRODUCT_KEY,
  ON_HAND_QTY, ON_ORDER_QTY, REORDER_POINT, UNIT_COST
) VALUES (
  s.INVENTORY_ID, s.SNAPSHOT_DATE, s.STORE_KEY, s.PRODUCT_KEY,
  s.ON_HAND_QTY, s.ON_ORDER_QTY, s.REORDER_POINT, s.UNIT_COST
);

=================================================================

USE SCHEMA CHROMA.PRS;

-- Product catalog (for lookup/filtering)
CREATE OR REPLACE VIEW VW_PRODUCT_CATALOG AS
SELECT
  p.PRODUCT_KEY, p.PRODUCT_ID, p.PRODUCT_SKU, p.PRODUCT_NAME, p.BRAND,
  p.CATEGORY, p.SUBCATEGORY, p.COLOR, p.SIZE, p.UNIT_PRICE, p.IS_ACTIVE
FROM CHROMA.INT.DIM_PRODUCT p;

-- Daily sales by store/product
CREATE OR REPLACE VIEW VW_SALES_DAILY_STORE_PRODUCT AS
SELECT
  fs.SALES_DATE,
  ds.STATE,
  ds.CITY,
  ds.STORE_NAME,
  dp.CATEGORY,
  dp.SUBCATEGORY,
  dp.PRODUCT_NAME,
  SUM(fs.QUANTITY)   AS QTY_SOLD,
  SUM(fs.NET_AMOUNT) AS NET_SALES
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_STORE   ds ON fs.STORE_KEY   = ds.STORE_KEY
JOIN CHROMA.INT.DIM_PRODUCT dp ON fs.PRODUCT_KEY = dp.PRODUCT_KEY
GROUP BY 1,2,3,4,5,6,7;

-- Inventory on hand by store/product/date
CREATE OR REPLACE VIEW VW_INVENTORY_ONHAND_BY_STORE AS
SELECT
  fi.SNAPSHOT_DATE,
  ds.STATE,
  ds.CITY,
  ds.STORE_NAME,
  dp.CATEGORY,
  dp.SUBCATEGORY,
  dp.PRODUCT_NAME,
  fi.ON_HAND_QTY,
  fi.ON_ORDER_QTY,
  fi.REORDER_POINT
FROM CHROMA.INT.FACT_INVENTORY fi
JOIN CHROMA.INT.DIM_STORE   ds ON fi.STORE_KEY   = ds.STORE_KEY
JOIN CHROMA.INT.DIM_PRODUCT dp ON fi.PRODUCT_KEY = dp.PRODUCT_KEY;

-- Customer lifetime value (simple)
CREATE OR REPLACE VIEW VW_CUSTOMER_LIFETIME_VALUE AS
SELECT
  dc.CUSTOMER_KEY,
  dc.FIRST_NAME,
  dc.LAST_NAME,
  dc.CITY,
  dc.STATE,
  dc.LOYALTY_TIER,
  COUNT(DISTINCT fs.TRANSACTION_ID) AS ORDERS,
  SUM(fs.NET_AMOUNT)                AS LIFETIME_NET_SPEND
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_CUSTOMER dc ON fs.CUSTOMER_KEY = dc.CUSTOMER_KEY
GROUP BY 1,2,3,4,5,6;

============================================

--KPI's from Data

-- MoM Net Sales

SELECT TO_CHAR(SALES_DATE, 'YYYY-MM') AS month,
       SUM(NET_AMOUNT) AS net_sales,
       (SUM(NET_AMOUNT) - LAG(SUM(NET_AMOUNT)) OVER (ORDER BY TO_CHAR(SALES_DATE,'YYYY-MM')))
       / NULLIF(LAG(SUM(NET_AMOUNT)) OVER (ORDER BY TO_CHAR(SALES_DATE,'YYYY-MM')),0) * 100
       AS mom_change_pct
FROM CHROMA.INT.FACT_SALES
GROUP BY TO_CHAR(SALES_DATE, 'YYYY-MM')
ORDER BY month;

---Top Products

SELECT dp.PRODUCT_NAME, dp.CATEGORY, dp.SUBCATEGORY,
       SUM(fs.QUANTITY) AS qty_sold,
       SUM(fs.NET_AMOUNT) AS net_sales
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_PRODUCT dp ON fs.PRODUCT_KEY = dp.PRODUCT_KEY
GROUP BY dp.PRODUCT_NAME, dp.CATEGORY, dp.SUBCATEGORY
ORDER BY net_sales DESC, qty_sold DESC
FETCH FIRST 50 ROWS;

-- Store performance (highest / lowest)

-- Highest
SELECT ds.STORE_NAME, ds.CITY, ds.STATE,
       SUM(fs.NET_AMOUNT) AS net_sales, SUM(fs.QUANTITY) AS qty
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_STORE ds ON fs.STORE_KEY = ds.STORE_KEY
GROUP BY ds.STORE_NAME, ds.CITY, ds.STATE
ORDER BY net_sales DESC
FETCH FIRST 50 ROWS;

-- Lowest
SELECT ds.STORE_NAME, ds.CITY, ds.STATE,
       SUM(fs.NET_AMOUNT) AS net_sales, SUM(fs.QUANTITY) AS qty
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_STORE ds ON fs.STORE_KEY = ds.STORE_KEY
GROUP BY ds.STORE_NAME, ds.CITY, ds.STATE
ORDER BY net_sales ASC
FETCH FIRST 50 ROWS;


--Stores with highest “inventory lying unsold”

-- Get latest snapshot date (inventory)
WITH last_snap AS (
  SELECT MAX(SNAPSHOT_DATE) AS max_dt FROM CHROMA.INT.FACT_INVENTORY
),
inv AS (
  SELECT fi.STORE_KEY,
         SUM(fi.ON_HAND_QTY * fi.UNIT_COST) AS inventory_value
  FROM CHROMA.INT.FACT_INVENTORY fi, last_snap
  WHERE fi.SNAPSHOT_DATE = last_snap.max_dt
  GROUP BY fi.STORE_KEY
),
sales_30d AS (
  SELECT fs.STORE_KEY,
         SUM(fs.NET_AMOUNT) AS sales_value_30d
  FROM CHROMA.INT.FACT_SALES fs, last_snap
  WHERE fs.SALES_DATE > DATEADD(day, -30, last_snap.max_dt)
    AND fs.SALES_DATE <= last_snap.max_dt
  GROUP BY fs.STORE_KEY
)
SELECT ds.STORE_NAME, ds.CITY, ds.STATE,
       inv.inventory_value,
       COALESCE(sales_30d.sales_value_30d, 0) AS sales_value_30d,
       CASE WHEN COALESCE(sales_30d.sales_value_30d,0)=0 THEN NULL
            ELSE inv.inventory_value / sales_30d.sales_value_30d END
         AS inventory_to_sales_ratio
FROM inv
LEFT JOIN sales_30d USING (STORE_KEY)
JOIN CHROMA.INT.DIM_STORE ds USING (STORE_KEY)
ORDER BY inventory_to_sales_ratio DESC NULLS LAST, inv.inventory_value DESC
FETCH FIRST 50 ROWS;

=============================================================================
/**RBAC**/


-- Base roles
CREATE ROLE IF NOT EXISTS CHROMA_ADMIN;
CREATE ROLE IF NOT EXISTS CHROMA_ENG;
CREATE ROLE IF NOT EXISTS CHROMA_PIPE;
CREATE ROLE IF NOT EXISTS CHROMA_ANALYST;
CREATE ROLE IF NOT EXISTS CHROMA_POWER_USER;
CREATE ROLE IF NOT EXISTS CHROMA_AUDITOR;
CREATE ROLE IF NOT EXISTS CHROMA_SUPPORT;

-- Hierarchy: Admin inherits all; SYSADMIN sees admin (optional, org standard)
GRANT ROLE CHROMA_ENG         TO ROLE CHROMA_ADMIN;
GRANT ROLE CHROMA_PIPE        TO ROLE CHROMA_ADMIN;
GRANT ROLE CHROMA_ANALYST     TO ROLE CHROMA_ADMIN;
GRANT ROLE CHROMA_POWER_USER  TO ROLE CHROMA_ADMIN;
GRANT ROLE CHROMA_AUDITOR     TO ROLE CHROMA_ADMIN;
GRANT ROLE CHROMA_SUPPORT     TO ROLE CHROMA_ADMIN;

-- Optionally attach project admin to SYSADMIN (org convention)
GRANT ROLE CHROMA_ADMIN TO ROLE SYSADMIN;

-- Run as ACCOUNTADMIN or a role that owns warehouses

GRANT USAGE, OPERATE ON WAREHOUSE WH_INGEST   TO ROLE CHROMA_PIPE;
GRANT USAGE, OPERATE ON WAREHOUSE WH_INGEST   TO ROLE CHROMA_ENG;

GRANT USAGE, OPERATE ON WAREHOUSE WH_TRANSFORM TO ROLE CHROMA_ENG;
GRANT USAGE, OPERATE ON WAREHOUSE WH_TRANSFORM TO ROLE CHROMA_ADMIN;

GRANT USAGE ON WAREHOUSE WH_BI TO ROLE CHROMA_ANALYST;
GRANT USAGE ON WAREHOUSE WH_BI TO ROLE CHROMA_POWER_USER;
GRANT USAGE ON WAREHOUSE WH_BI TO ROLE CHROMA_AUDITOR;

-- Run as SYSADMIN (or object owner)
USE DATABASE CHROMA;

-- Database USAGE
GRANT USAGE ON DATABASE CHROMA TO ROLE CHROMA_ANALYST
GRANT USAGE ON DATABASE CHROMA TO ROLE CHROMA_POWER_USER
CHROMA_AUDITOR,  CHROMA_ENG,  CHROMA_PIPE,  CHROMA_ADMIN;

-- Schema USAGE (no object access yet)
GRANT SELECT ON ALL TABLES IN SCHEMA CHROMA.STG
TO ROLE CHROMA_AUDITOR, CHROMA_ENG, CHROMA_ANALYST;


-- Read raw only for audit/eng; load rights only for pipeline role
GRANT SELECT ON ALL TABLES IN SCHEMA CHROMA.STG TO ROLE CHROMA_AUDITOR, ROLE CHROMA_ENG;
GRANT SELECT ON FUTURE TABLES IN SCHEMA CHROMA.STG TO ROLE CHROMA_AUDITOR, ROLE CHROMA_ENG;

-- Pipeline needs to COPY/INSERT into STG tables
GRANT INSERT, SELECT ON ALL TABLES IN SCHEMA CHROMA.STG TO ROLE CHROMA_PIPE;
GRANT INSERT, SELECT ON FUTURE TABLES IN SCHEMA CHROMA.STG TO ROLE CHROMA_PIPE;

-- External stage + pipes
GRANT USAGE ON STAGE CHROMA.STG.AZ_STAGE TO ROLE CHROMA_PIPE, ROLE CHROMA_ENG;
GRANT MONITOR ON PIPE CHROMA.STG.P_PRODUCT   TO ROLE CHROMA_SUPPORT, ROLE CHROMA_AUDITOR;
GRANT MONITOR ON PIPE CHROMA.STG.P_EMPLOYEE  TO ROLE CHROMA_SUPPORT, ROLE CHROMA_AUDITOR;
GRANT MONITOR ON PIPE CHROMA.STG.P_CUSTOMER  TO ROLE CHROMA_SUPPORT, ROLE CHROMA_AUDITOR;
GRANT MONITOR ON PIPE CHROMA.STG.P_STORE     TO ROLE CHROMA_SUPPORT, ROLE CHROMA_AUDITOR;
GRANT MONITOR ON PIPE CHROMA.STG.P_SALES     TO ROLE CHROMA_SUPPORT, ROLE CHROMA_AUDITOR;
GRANT MONITOR ON PIPE CHROMA.STG.P_INVENTORY TO ROLE CHROMA_SUPPORT, ROLE CHROMA_AUDITOR;

-- Engineers: full DML on INT (build & maintain)
GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES
  ON ALL TABLES IN SCHEMA CHROMA.INT TO ROLE CHROMA_ENG;
GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES
  ON FUTURE TABLES IN SCHEMA CHROMA.INT TO ROLE CHROMA_ENG;

-- Power users: read-only INT (for deeper analysis)
GRANT SELECT ON ALL TABLES IN SCHEMA CHROMA.INT TO ROLE CHROMA_POWER_USER;
GRANT SELECT ON FUTURE TABLES IN SCHEMA CHROMA.INT TO ROLE CHROMA_POWER_USER;

-- Analysts: read presentation views only
GRANT SELECT ON ALL VIEWS IN SCHEMA CHROMA.PRS TO ROLE CHROMA_ANALYST;
GRANT SELECT ON FUTURE VIEWS IN SCHEMA CHROMA.PRS TO ROLE CHROMA_ANALYST;

-- Power users & auditors can also read PRS
GRANT SELECT ON ALL VIEWS IN SCHEMA CHROMA.PRS TO ROLE CHROMA_POWER_USER, ROLE CHROMA_AUDITOR;
GRANT SELECT ON FUTURE VIEWS IN SCHEMA CHROMA.PRS TO ROLE CHROMA_POWER_USER, ROLE CHROMA_AUDITOR;

-- (Optional) Let power users create sandbox views in PRS (not tables)
GRANT CREATE VIEW ON SCHEMA CHROMA.PRS TO ROLE CHROMA_POWER_USER;




/**PRS LAYER**/

USE SCHEMA CHROMA.PRS;

-- Simple dimension views
CREATE OR REPLACE VIEW VW_PRODUCT_CATALOG AS
SELECT PRODUCT_KEY, PRODUCT_ID, PRODUCT_SKU, PRODUCT_NAME, BRAND, CATEGORY, SUBCATEGORY,
       COLOR, SIZE, UNIT_PRICE, IS_ACTIVE
FROM CHROMA.INT.DIM_PRODUCT;

CREATE OR REPLACE VIEW VW_STORES AS
SELECT STORE_KEY, STORE_ID, STORE_NAME, STORE_NUMBER, FORMAT, CITY, STATE, REGION, SQ_FT, OPEN_DATE, CLOSE_DATE
FROM CHROMA.INT.DIM_STORE;

CREATE OR REPLACE VIEW VW_SALES_DAILY_STORE_PRODUCT AS
SELECT
  fs.SALES_DATE,
  ds.STORE_NAME,
  dp.PRODUCT_NAME,
  SUM(fs.QUANTITY)      AS QTY_SOLD,
  SUM(fs.NET_AMOUNT)    AS NET_SALES
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_STORE ds   ON fs.STORE_KEY   = ds.STORE_KEY
JOIN CHROMA.INT.DIM_PRODUCT dp ON fs.PRODUCT_KEY = dp.PRODUCT_KEY
GROUP BY 1,2,3;


CREATE OR REPLACE VIEW VW_INVENTORY_ONHAND_BY_STORE AS
SELECT
  fi.SNAPSHOT_DATE,
  ds.STORE_NAME,
  dp.PRODUCT_NAME,
  fi.ON_HAND_QTY,
  fi.ON_ORDER_QTY,
  fi.REORDER_POINT
FROM CHROMA.INT.FACT_INVENTORY fi
JOIN CHROMA.INT.DIM_STORE ds   ON fi.STORE_KEY   = ds.STORE_KEY
JOIN CHROMA.INT.DIM_PRODUCT dp ON fi.PRODUCT_KEY = dp.PRODUCT_KEY;


CREATE OR REPLACE VIEW VW_CUSTOMER_LIFETIME_VALUE AS
SELECT
  dc.CUSTOMER_KEY,
  dc.CUSTOMER_ID,
  dc.FIRST_NAME,
  dc.LAST_NAME,
  SUM(fs.NET_AMOUNT) AS LIFETIME_NET_SPEND,
  COUNT(DISTINCT fs.TRANSACTION_ID) AS ORDERS
FROM CHROMA.INT.FACT_SALES fs
JOIN CHROMA.INT.DIM_CUSTOMER dc ON fs.CUSTOMER_KEY = dc.CUSTOMER_KEY
GROUP BY 1,2,3,4;

/** Time Travel**/

ALTER DATABASE CHROMA SET DATA_RETENTION_TIME_IN_DAYS = 7;
ALTER SCHEMA CHROMA.STG SET DATA_RETENTION_TIME_IN_DAYS = 1;
ALTER SCHEMA CHROMA.INT SET DATA_RETENTION_TIME_IN_DAYS = 14;
ALTER SCHEMA CHROMA.PRS SET DATA_RETENTION_TIME_IN_DAYS = 3;

CREATE OR REPLACE TABLE FACT_SALES_RESCUE
CLONE FACT_SALES AT (TIMESTAMP => ''::timestamp);

ALTER TABLE FACT_SALES SWAP WITH FACT_SALES_RESCUE;

CREATE OR REPLACE TEMP TABLE FACT_SALES_PAST AS
SELECT *
FROM FACT_SALES AT (TIMESTAMP => ''::timestamp)
WHERE SALES_DATE BETWEEN '' AND '';

DELETE FROM FACT_SALES
 WHERE SALES_DATE BETWEEN '2025-09-01' AND '2025-09-07';

INSERT INTO FACT_SALES
SELECT * FROM FACT_SALES_PAST;
